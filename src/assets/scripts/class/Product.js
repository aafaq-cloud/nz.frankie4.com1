import {formatMoney} from "@shopify/theme-currency";
import EventEmitter from "event-emitter-es6";
import $ from "jquery";
import {VariantSelector} from "./VariantSelector";

export class Product extends EventEmitter {
  /**
   * Product constructor
   *
   * @param options Settings object used to construct product class
   *            @type container The product container DOM element
   *            @type product The product json object (generated by Shopify)
   */
  constructor(options) {
    super();

    if (options.hasOwnProperty("container")) {
      this.container = options.container;
    }

    if (options.hasOwnProperty("product")) {
      this.product = options.product;
    }

    this.products = [];
    this.setProducts();

    // We will only initialise the variant bindings if we have a product container and product data
    if (this.hasOwnProperty("container") && this.hasOwnProperty("product")) {
      this.quickview = this.container.classList.contains('is-quickview') > -1;
      this.setVariantGroups();
      this.setSelectors();
      this.initVariantSelectors();
      this.updateSelectedVariant();
      this.initAddToCart();
    }
  }

  setProducts() {
    const instance = this;
    instance.products = JSON.parse(instance.container.querySelector("[data-related-products-json]").innerHTML).products;

  }

  /**
   * Set the selectors and matching elements
   */
  setSelectors() {
    const selectors = {
      comparePrice: "[data-compare-price]",
      form: "[data-product-form]",
      productID: "[data-product-id]",
      productPrice: "[data-product-price]",
      properties: "[name^=\"properties\"]"
    };

    const selectorsSingle = {
      addToCart: "[data-add-to-cart]",
      addToCartText: "[data-add-to-cart-text]",
      quantitySelector: "[data-quantity-selector]",
      errorMessage: "[data-add-to-cart-error]"
    };

    this.selectors = {};

    for (const key in selectors) {
      if (selectors.hasOwnProperty(key)) {
        this.selectors[key] = this.container.querySelectorAll(selectors[key]);
      }
    }

    this.selectorsSingle = {};

    for (const key in selectorsSingle) {
      if (selectorsSingle.hasOwnProperty(key)) {
        this.selectorsSingle[key] = this.container.querySelector(
          selectorsSingle[key]
        );
      }
    }
  }

  /**
   * Initialise the variant selector listeners
   */
  initVariantSelectors() {
    this.variantSelectors = [];

    // If there are no variants for this product
    if (
      this.product.options.length === 1 &&
      this.product.options[0] === "Title" &&
      this.product.variants.length === 1
    ) {
      this.updateSelectedVariant();
      return;
    }

    for (let i = 0; i < this.product.options.length; ++i) {
      const variantSelector = new VariantSelector(i, this.container);
      this.variantSelectors.push(variantSelector);
      variantSelector.on("change", () => {
        this.updateSelectedVariant();
      });
    }
  }

  /**
   * Get the selected variant
   *
   * @returns {null|*}
   */
  getSelectedVariant() {
    return this.selectedVariant;
  }

  /**
   * Set the selected variant
   */
  setSelectedVariant() {
    let found = null;

    if (this.product.variants.length === 1) {
      found = this.product.variants[0];
    } else {
      // Loop through each variant and find a match
      for (let v = 0; v < this.product.variants.length; v++) {
        const variant = this.product.variants[v];

        let satisfied = false;

        // Loop through the variant options
        for (let i = 0; i < variant.options.length; ++i) {
          satisfied = false;

          // Loop through the variant selectors
          for (let j = 0; j < this.variantSelectors.length; ++j) {
            // Check if the variant select value matches the variant option
            if (
              String(variant.options[i]) ===
              String(this.variantSelectors[j].getValue())
            ) {
              satisfied = true;
              break;
            }
          }

          // If we do not have a match let's break out of the loop and move onto the next variant
          if (!satisfied) {
            break;
          }
        }

        if (satisfied) {
          found = variant;
          // break;
        }
      }
    }

    this.selectedVariant = found || null;
  }

  /**
   * Create a mapping object of Product Variants and their dependant variants
   * Variant option priority is determined by the order they appear in the admin
   *
   * Example structure:
   * {
   *   Blue: {
   *     available: true,
   *     options: {
   *       Small: {
   *         available: false,
   *         options: {
   *           Cotton: {
   *             available: false,
   *             options: {}
   *           }
   *         }
   *       },
   *       Medium: {
   *         available: true,
   *         options: {
   *           Cotton: {
   *             available: true,
   *             options: {}
   *           },
   *           Polyester: {
   *             available: true,
   *             options: {}
   *           }
   *         }
   *       }
   *     }
   *   },
   *   Red: {
   *     available: false,
   *     options: {
   *       Small: {
   *         available: false,
   *       }
   *     }
   *   }
   * }
   *
   */
  setVariantGroups() {
    this.variantGroups = {};

    // Loop through each product variant
    for (let v = 0; v < this.product.variants.length; v++) {
      const variant = this.product.variants[v];

      // First Level
      for (let i = 0; i < this.product.options.length; ++i) {
        const variantOption = variant.options[i];

        // If the option is the root option
        if (i === 0) {
          // Add this option to the root options if it isn't already
          if (!this.variantGroups.hasOwnProperty(variantOption)) {
            this.variantGroups[variantOption] = {
              available: false,
              options: {}
            };
          }

          if (variant.available) {
            this.variantGroups[variantOption].available = true;
          }
          // Second Level
        } else if (i === 1) {
          // Add this option to the root options if it isn't already
          if (
            !this.variantGroups[variant.options[0]].options.hasOwnProperty(
              variantOption
            )
          ) {
            this.variantGroups[variant.options[0]].options[variantOption] = {
              available: false,
              options: {}
            };
          }

          if (variant.available) {
            this.variantGroups[variant.options[0]].options[
              variantOption
            ].available = true;
          }
          // Third Level
        } else if (i === 2) {
          // Add this option to the root options if it isn't already
          if (
            !this.variantGroups[variant.options[0]].options[
              variant.options[1]
            ].options.hasOwnProperty(variantOption)
          ) {
            this.variantGroups[variant.options[0]].options[
              variant.options[1]
            ].options[variantOption] = {
              available: false,
              options: {}
            };
          }

          if (variant.available) {
            this.variantGroups[variant.options[0]].options[
              variant.options[1]
            ].options[variantOption].available = true;
          }
        }
      }
    }
  }

  /**
   * Update the selected variant and call the appropriate methods to update the DOM
   */
  updateSelectedVariant() {
    this.updateVariantSelectorOptions();
    this.setSelectedVariant();
    this.updateProductPrices();
    this.updateAddToCartState();
    this.updateProductID();
    this.updateHistoryState();


    this.updateSwatches();


    this.emit("variant-change", this.selectedVariant);

    const event = document.createEvent("Event");
    event.initEvent("shopify-currency.refresh", null, null);
    document.body.dispatchEvent(event);
  }

  /**
   * Update the product swatch availablity and href/data-product-url
   */
  updateSwatches(){

    // Get which index of the selected variant is Size
    let options = this.product.options;
    let sizeIndex = options.indexOf("Size");
    let currentSize = this.selectedVariant.options[sizeIndex];

    // array of variants of active size with product id as key
    let relatedVariants = this.getSelectedProducts(currentSize);

    // dom element of swatches
    let swatches = this.container.querySelectorAll('.product-swatches__product');

    // loop through swatches to update disabled state and update href/data-product-url
    for (let i = 0; i < swatches.length; i++) {
      let swatch = swatches[i];
      let currentVariant = relatedVariants[swatch.getAttribute('data-product-id')];

      if (currentVariant != undefined) {
        if (currentVariant.available){
          swatch.classList.remove('disabled');
          if (swatch.hasAttribute('data-product-quickview')) {
            swatch.setAttribute('data-product-url','/products/' + swatch.getAttribute('data-product-handle') + '?variant=' + currentVariant.id);
          } else {
            swatch.setAttribute('href','/products/' + swatch.getAttribute('data-product-handle') + '?variant=' + currentVariant.id);
          }
        } else { // If this product for the active size is not availble
          swatch.classList.add('disabled');
          if (swatch.hasAttribute('data-product-quickview')) {
            swatch.setAttribute('data-product-url', '');
          } else {
            swatch.setAttribute('href', '#');
          }
        }
      }

    }

  }

  /**
   * Update the variant selector options
   * Traverses the selectors to change options based on parent selectors
   */
  updateVariantSelectorOptions() {
    let availableOptionsMap = this.variantGroups;
    let availableOptions = [];

    // Loop through variant selectors to honour hierarchy
    for (let i = 0; i < this.variantSelectors.length; ++i) {
      availableOptions = {};

      for (const key in availableOptionsMap) {
        if (availableOptionsMap.hasOwnProperty(key)) {
          availableOptions[key] = availableOptionsMap[key].available;
        }
      }

      // Set the available options for the selector
      this.variantSelectors[i].setAvailableValues(availableOptions);

      // Let's point the available options map to the options for the current option selected
      availableOptionsMap =
        availableOptionsMap[this.variantSelectors[i].getValue()].options;
    }
  }

  /**
   * Update the add to cart button state and text
   */
  updateAddToCartState() {
    if (this.selectedVariant && this.selectedVariant.available) {
      this.selectorsSingle.addToCart.disabled = false;
      this.selectorsSingle.addToCartText.innerHTML = theme.strings.addToCart;
    } else {
      this.selectorsSingle.addToCart.disabled = true;
      this.selectorsSingle.addToCartText.innerHTML = theme.strings.soldOut;
    }
  }

  /**
   * Update the DOM prices for the active variant
   */
  updateProductPrices() {
    for (let i = 0; i < this.selectors.productPrice.length; ++i) {
      const productPriceSelector = this.selectors.productPrice[i];

      if (!this.selectedVariant) {
        productPriceSelector.classList.add("invisible");
        if (this.selectors.comparePrice) {
          for (let j = 0; j < this.selectors.comparePrice.length; j++) {
            this.selectors.comparePrice[j].classList.add("hide");
          }
        }
        break;
      } else {
        productPriceSelector.classList.remove("invisible");
      }

      const divider = productPriceSelector.getAttribute(
        "data-product-price-divide"
      )
        ? productPriceSelector.getAttribute("data-product-price-divide")
        : 1;

      productPriceSelector.innerHTML = formatMoney(
        this.selectedVariant.price / divider,
        theme.moneyFormat
      );
    }

    // Update compare at price label
    if (this.selectors.comparePrice) {
      if (this.selectedVariant.compare_at_price > this.selectedVariant.price) {
        for (let j = 0; j < this.selectors.comparePrice.length; ++j) {
          this.selectors.comparePrice[j].innerHTML = formatMoney(
            this.selectedVariant.compare_at_price,
            theme.moneyFormat
          );
          this.selectors.comparePrice[j].classList.remove("hide");
        }
      } else {
        for (let j = 0; j < this.selectors.comparePrice.length; ++j) {
          this.selectors.comparePrice[j].innerHTML = "";
          this.selectors.comparePrice[j].classList.add("hide");
        }
      }
    }
  }

  /**
   * Update the master product selector value
   */
  updateProductID() {
    if (this.selectedVariant) {
      this.selectors.productID.value = this.selectedVariant.id;
    }
  }

  /**
   * Update the url when a variant is selected
   */
  updateHistoryState() {
    if (
      !history.replaceState ||
      this.quickview ||
      !this.selectedVariant ||
      this.product.variants.length < 2
    ) {
      return;
    }

    const newurl = `${window.location.protocol}//${window.location.host}${
      window.location.pathname
    }?variant=${this.selectedVariant.id}`;
    window.history.replaceState({path: newurl}, "", newurl);
  }

  /**
   * Initialise the add to cart functionality
   * Handles the calling of the add to cart ajax function
   * and handles the success or fail responses accordingly
   */
  initAddToCart() {
    let formSubmitting = false;
    let clearErrorTimeout = null;

    const form = this.selectors.form.length ? this.selectors.form[0] : false;

    if (!form) {
      return;
    }

    form.addEventListener("submit", e => {
      // Let's intercept the form submission and add the item to the cart via ajax
      e.preventDefault();

      if (formSubmitting) {
        return;
      }

      formSubmitting = true;

      const variantID = this.selectors.productID.value;
      const quantity = this.selectorsSingle.quantitySelector.value;
      const properties = {};

      if (this.selectors.properties.length) {
        for (let i = 0; i < this.selectors.properties.length; i++) {
          if (this.selectors.properties[i].value) {
            const key = this.selectors.properties[i]
              .getAttribute("name")
              .replace(/.*\[|\]/gi, "");
            properties[key] = this.selectors.properties[i].value;
          }
        }
      }

      this.clearErrorMessage();
      clearTimeout(clearErrorTimeout);

      this.selectorsSingle.addToCart.classList.add("js-loading", "no-hover");
      this.selectorsSingle.addToCartText.innerHTML = "Adding to bag";

      // Trigger an add to cart ajax function
      AppShopifyCart.addItem(variantID, quantity, properties).then(
        () => {
          // If we successfully added the item to cart we will show a success message
          this.selectorsSingle.addToCart.classList.remove("js-loading");
          this.selectorsSingle.addToCart.classList.add("added");
          this.selectorsSingle.addToCartText.innerHTML = "Added to bag";

          // Clear the success button styles
          setTimeout(() => {
            this.selectorsSingle.addToCart.classList.remove(
              "added",
              "no-hover"
            );
            this.updateAddToCartState();
            formSubmitting = false;
          }, 3000);
        },
        errorData => {
          // If the add to cart returns an error let's show the error message
          if (
            typeof errorData.description === "string" &&
            errorData.description !== ""
          ) {
            this.selectorsSingle.errorMessage.innerHTML = errorData.description;
            this.selectorsSingle.errorMessage.classList.add("visible");
          }

          this.selectorsSingle.addToCart.classList.remove(
            "js-loading",
            "no-hover"
          );
          this.updateAddToCartState();
          formSubmitting = false;

          // Hide the error message again after a timeout
          clearErrorTimeout = setTimeout(() => {
            this.clearErrorMessage();
          }, 5000);
        }
      );
    });
  }


  /**
   * Accepts a size and loops through array of related products
   * and constructs an array where key is the product ID and the value
   * is the variant object of that product for the correct size
   * @param size String of the current size (e.g. 6)
   * @return array
   */
  getSelectedProducts(size){
    const instance = this;

    let variantsList = [];

    for (let i = 0; i < instance.products.length; i++) {
      let productObject = instance.products[i];
      let options = productObject.options;
      let sizeIndex = options.indexOf("Size");

      for (let i = 0; i < productObject.variants.length; i++) {
        if (productObject.variants[i].options[sizeIndex] == size) {
          variantsList[productObject.id] = productObject.variants[i];
        }
      }

    }

    return variantsList;

  }

  /**
   * Clear the add to cart error message
   */
  clearErrorMessage() {
    if (this.selectorsSingle.errorMessage) {
      this.selectorsSingle.errorMessage.innerHtml = "";
      this.selectorsSingle.errorMessage.classList.remove("visible");
    }
  }
}
